



\section{Approach} \label{sec:approach}
This section describes our approach and gives an insight of the process supporting it. In the first step, we show how to improve the performance of the 
decision making process by reducing the number of access control rules that have to be considered at the evaluation time. Secondly, we show how to select 
the splitting criterion that preserves the synergy requirement in the access control architecture.

\subsection{XACML Policy Refactoring Process}
What happens in a request evaluation process is that for a given access control request, some rules are evaluated in the global policy whereas some of those rules are not
 applicable to the request. Starting from this observation, we propose a scenario in which only the relevant rules for a given request will be evaluated
 in the decision making process, this scenario is based on a refactoring operation that consists in automating the policy splitting 
into smaller policies based on attribute values combination. We transform a policy P into smaller policies \normalsize $P_{SC_{w}}$ where each policy
 conforms to a Splitting Criteria $SC_{w}$.
An $SC_{w}$ defines the set of attributes that can be considered to classify all the rules into sets having the 
same attribute values. $w$ denotes the number of attributes that have to be considered conjointly for aggregating rules into
 a unified set based on specific attribute elements selection.

An XACML policy can be refactored considering one attribute element. In this case a policy can be split into a set of policies where the 
rules have the same subject, resource, or action. Rules can also be aggregated considering two attributes like $<Subject, Action>$ or
 $<Action, Resource>$, in this setting, a policy will be transformed into a set of smaller policies where rules in the resulting policies have the same 
couple of attribute elements. 
We can go further in our grouping strategy when using $P_{SC_{w}}$ whose 
rules match a specific triplet of resource, action and subject. Table I shows all splitting criteria categories according to the attribute elements combination.


\begin{table}[h!]
\centering
\setlength{\extrarowheight}{6 pt}
\begin{tabular}{|>{\small}c|>{\small}c|} 
\hline  \rowcolor{black} 
 \bf
\textcolor{white}{Categories}& \bf \textcolor{white}{Splitting Criteria}\\ \hline
 $SC_{1}$& {$<Subject>, <Resource>, <Action>$}\\ \hline

$SC_{2}$& {$<Subject,Action>, <Subject,Resource>$}\\&{$<Resource,Action>$}\\  \hline

$SC_{3}$& {$<Subject,Resource,Action>$}\\ \hline
\end{tabular}
\caption{Splitting Criteria}

\label{table1}\end{table}

We propose an access control architecture built with multiple (PDPs), where each PDP enforces
a policy that complies with a certain splitting criterion. 

\subsection{Architecture Model Preservation: PEP-PDP Synergy}
We consider the different splitting criteria that we have identified in the previous section and we propose to select the splitting 
criteria that enables preserving the synergy property in the access control architecture.
The selected splitting criteria should enable to have multiple policies encapsulated in several PDPs 
where each PDP is mapped to a single PEP.
A PEP-PDP mapping is observable through the code at application level. In fact, a deep analysis of the PEPs and 
the corresponding triggered rules, enables to explicitly describe this mapping. At the application level, every PEP is mapped to a 
service implementation through a system method call that triggers a decision making process by activating some specific rules in a single 
PDP.

The code below is taken from \cite{legacy}, this code excerpt shows an example of a PEP which is implemented by the method 
checkSecurity, this method calls the class SecurityPolicyService that initiates the PDP component.
\begin{algorithmic}
\begin{algorithm}[!h]
%\caption{System security function that describes a PEP enforcement}
   \STATE public void borrowBook(User user, Book book)
   \STATE throws SecuritPolicyViolationException {
   \STATE   // call to the security service
\STATE \hspace{0.5cm} \textbf{ServiceUtils.checkSecurity(user,
\STATE LibrarySecurityModel.BORROWBOOK\_METHOD,
\STATE LibrarySecurityModel.BOOK\_VIEW);
\STATE ContextManager.getTemporalContext());}
    \STATE  // call to business objects
    \STATE  // borrow the book for the user
\STATE \hspace{0.5cm} book.execute(Book.BORROW, user);
\STATE      // call the dao class to update the DB
\STATE \hspace{0.5cm} bookDAO.insertBorrow(userDTO, bookDTO);}
\end{algorithm}
\end{algorithmic}

An analysis of this code reflects that this function will trigger exclusively all the rules organized by the couple (Action, Resource) for 
the subject given as input parameter. This is due to the call of the following methods: LibrarySecurityModel.BORROWBOOK\_METHOD and 
LibrarySecurityModel.BOOK\_VIEW.

%%%%%
Conceptually, we propose to transform the global policy into subsets of rules where each subset can be mapped to a PEP.
In this setting, each single request initiated by a specific PEP will have its corresponding evaluating PDP conforming to the PEP-PDP matching. 
This implies that the different method calls initiated by PEPs are identified at the code level at the decision making time and mapped to their 
corresponding PDPs. A mapping table is used to establish the link between each PEP implementation and the corresponding rules 
encapsulated in a given PDP. A general schema for this approach is presented in Figure \ref{decomposition}.b.

Figure \ref{synergy} synthesizes the concept of synergy between PEPs and corresponding PDPs. In the worse case, splitting the initial PDP into multi-PDPs may lead to a non-synergic system: a PEP may send its requests to several PDPs. The PDP, which receives a request is only known at runtime. Such a resulting architecture breaks the PEP-PDP synergy and the conceptual 
simplicity of the initial architecture model. The splitting criteria which lead to such a non-synergic architecture is not a valid refactoring: 
the complexity induced by the splitting, makes the maintenance and evolution of the system more difficult to manage.
In the best case, the refactoring preserves the simplicity of the initial architecture, by keeping a many-to-one association from PEPs to PDPs. A given request evaluation 
triggered by one PEP will always be handled by the same PDP. Operationally, the request evaluation process will involve 
one XACML policy file. In this case, the refactoring is valid, since its does not impact the conceptual architecture of the system.

Depending on the system architecture, establishing this mapping may require to identify all the enforcements points in an application, and to 
track the different method calls 
triggered from these specific enforcement calls to map them to the relevant access control rules.  
In this work, we analyze the best splitting criteria in our empirical studies, for these empirical studies, we know in advance our different PEPs and their corresponding relevant rules. 
%We propose to identify automatically the different PEPs in a future work, however for this work, we can identify easily the different PEPs as we know in
% advance that system functions are implemented through the consideration of (Resource, Action) target elements thus a policy refactoring according 
%to system function is assimilated to policy refactoring according to the splitting criteria SC$_{1}=<$Action,Resource$>$. 

Our empirical results, presented in section~\ref{sec:experiment}, have shown that adopting a policy refactoring based on system functions, as a refactoring strategy, enables to 
reduce the decision making time. 
%Our empirical results have constantly shown that adopting a policy refactoring based on system functions, as a refactoring strategy, enables to reduce the decision making time. 
This strategy takes into consideration how the PEPs interact with the PDPs, how the rules are activated across the system, and preserve
the architectue 	since we preserve the cardinality relation between PEPs and PDPs.
 
As depicted in Figure \ref{overallprocess}, the refactoring process is automated and starts by specifying and creating the XACML file which 
will be split by our tool according to a specified SC that can be chosen by an access control stakeholder. Afterwards, the policies are included in the 
framework that supports our approach. For every change in the access control policy, the initial policy is updated and 
split again in order to be included again in the framework.
From a point of view of the system administration, maintaining and updating the access control policies is completely a standalone and simple
 process. The input is usually a centralized XACML policy. This input remains the same than before the access control performance issue is tackled.
Our process is transparent in the sense that it does not impact the existing functional aspects of the access control management system, 
for system administrators, who have to update the policy fequently and have to manage various dimensions of access control 
systems such the scalability and maintainability.